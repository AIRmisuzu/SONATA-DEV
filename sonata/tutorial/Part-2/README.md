## Expressing Queries for Telemetry Applications 

In this part, we will learn how to express and test queries that detect:
* Newly-opened tcp connections. 
* IoT devices in the network. 

### Detecting Newly Opened TCP Connections
In part 1, we described how Sonata compiles different partitioning plans for this
query to the data plane. We ignored how the remaining dataflow operations were 
performed over the reported packet tuples in user-space. We will now describe how Sonata supports these
queries end-to-end and how to test these queries. 

#### Query
Recall that the query for this application is:
```python
Q = (PacketStream(qid)
     .filter(filter_keys=('tcp.flags',), func=('eq', 2))
     .map(keys=('ipv4.dstIP',), map_values=('count',), func=('eq', 1,))
     .reduce(keys=('ipv4.dstIP',), func=('sum',))
     .filter(filter_vals=('count',), func=('geq', 40))
     )
```

#### Testing
* Assuming that you are already `vagrant ssh`'ed to your VM, run the following command 
to clean up any stored results and any previously running processes.

```bash
$ cd ~/dev
$ sudo sh cleanup.sh
```

* You can find the query for this application at: 
`sonata/examples/newly_opened_connections/test_app.py`
  In this file, we manually specify a static query plan for each query. In practice, 
  Sonata's query planner takes the queries, training data, and the data plane target's various resource 
  constraints as input to solve an ILP.  The output of the ILP is a partitioning and refinement plan unique
  to those constraints that minimizes the load on the stream processor.
  In this case, we specify the query plan: `(1,32,5,1)`, i.e. for query `1`, use refinement level `/32`,
   and execute the first `5` dataflow operators in the data plane; for now, we can ignore the last field in the plan.

```bash
$ sudo $SPARK_HOME/bin/spark-submit sonata/examples/newly_opened_connections/test_app.py
```

* This file loads the newly-opened tcp connection query to the
runtime. The runtime then uses the configured query plan to partition and refine the 
input query and send the partitioned queries to respective target drivers. In this 
example, we use P4-BMV2 behavioral switch as the data plane target and Apache Spark 
Streaming as the streaming target. 

* You can check out the `P4` and `Spark` code generated by the respective drivers here:
    * `sonata/examples/newly_opened_connections/generated_src/compiled.p4`
    * `sonata/examples/newly_opened_connections/generated_src/spark.py`

* In a separate terminal session, send the (normal+attack) traffic by running 
the following command.
```bash
$ cd ~/dev	
$ sudo python sonata/examples/newly_opened_connections/send.py
```

#### Evaluating Results
Look at the file `~/dev/sonata/examples/newly_opened_connetions/logs/emitter.log` to see which tuples were reported to
the stream processor.


### Detecting IoT Devices

#### Background
The DNS fingerprint for IoT devices is different from other 
Internet-connected such as laptops, servers, and mobile devices etc.
Most IoT devices query a limited number of unique domains. For example,
a `Nest` thermostat mostly sends DNS queries for the domain `nest.com`.
To identify IoT devices, one can write queries to determine total
number of DNS responses received by a host and total number of unique
domains (also identifiable by the resolved IP address in the DNS 
response message). It can report hosts that receive more than `Th1`
total responses but for which the number of unique resolved IP addresses
is less than `Th2`.

#### Expressing the Query
We will now describe a simple query one can express with Sonata to detect the presence of
IoT devices. 
* Identify hosts that receive **more** than `Th1` number of DNS responses.
* Identify hosts for which the number of **unique** resolved IP addresses (`dns.an.rdata`)
 is **less** than `Th2`.

#### Testing
To test your query, follow the steps below:
* Do cleanup
````bash
$ cd ~/dev
$ sudo sh cleanup.sh
````

* Load the new application
````bash
$ cd ~/dev
$ sudo $SPARK_HOME/bin/spark-submit sonata/tutorial/Part-2/sonata_app.py
````

* Use a separate terminal to send the traffic
````bash
$ cd ~/dev	
$ sudo python sonata/tutorial/Part-2/send.py
````
 
Check the log files here: `sonata/tutorial/Part-2/logs`. `emitter.log` records the 
tuple reported to the stream processor and `final_output` records the final output 
of the query.

### Troubleshooting
* Make sure you load the app before sending the traffic.
* If your application crashes, be sure to run `cleanup.sh` immediately 
after the crash.
* In case you see a `mysql-connector` not found error, follow the steps below to fix this problem:
    * Install the missing package:
    ```bash
    $ sudo -H pip install mysql-connector==2.1.4
    ```
    * Create a `sonata` database:
    ```bash
    $ sudo mysql -e "create database sonata;"
    ```
    * Add a table:
    ```bash
    $ sudo mysql -e "CREATE TABLE indexStore( id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, qid INT(6),  tuple VARCHAR(200), indexLoc INT(6) );"
    ```
    
