## Expressing Dataflow Queries for Telemetry Applications 

In this part, we will cover how:
* One can use Sonata to run the `newly-opened-tcp-connection` application. 
* One can use Sonata for detecting IoT devices in the network. 

### Section 1: Detecting Newly Opened TCP Connections
In part 1, we described how Sonata compiles different partitioning plans for this
query in the data plane. We ignored how the remainder dataflow operations are 
performed over the packet tuples in the user space. We will now describe how one 
can use Sonata to express the query for such an application and how we can run 
end-to-end tests ensuring it works as expected. 

#### Query
Recall that the query for this application is:
```python
Q = (PacketStream(qid)
     .filter(filter_keys=('tcp.flags',), func=('eq', 2))
     .map(keys=('ipv4.dstIP',), map_values=('count',), func=('eq', 1,))
     .reduce(keys=('ipv4.dstIP',), func=('sum',))
     .filter(filter_vals=('count',), func=('geq', Th))
     )
```

#### Testing
* Assuming that you are already inside the vagrant VM. Run the following command 
to clean up any stored results and any previously running processes.
```bash
$ sudo sh cleanup.sh
```

* You can find the query for this application at: 
`sonata/examples/newly_opened_connections/test_app.py`
  In this file, we manually specify the query plan for each query. In practice, 
  Sonata's query planner takes the queries, training data, and target's various resource 
  constraints as input to solve an ILP determining how to iteratively refine each query
  and partition each refined query between the data plane and the stream processor.
  In this case, we just specify the query plan: (1,32,5,1), i.e. for query `1`, use 
  use refinement level `32`, execute first `5` dataflow operators in the data plane. 
  For this example, we can ignore the last field of the query plan. 

```bash
$ export SPARK_HOME=/home/vagrant/spark/
$ sudo $SPARK_HOME/bin/spark-submit sonata/examples/newly_opened_connections/sonata_app.py
```

* This file loads the query for the `newly-opened-tcp-connection` application to the
runtime. The runtime then uses the configured query plan to partition and refine the 
input query and send the partitioned queries to respective target drivers. In this 
example, we use P4-BMV2 behavioral switch as the data plane target and Apache Spark 
streaming as the streaming target. 

* You can check out the `P4` and `Spark` code generated by the respective drivers here:
    * `sonata/examples/newly_opened_connections/generated_src/compiled.p4`
    * `sonata/examples/newly_opened_connections/generated_src/compiled.python`

* In a separate terminal session, send the (normal+attack) traffic by running 
the following command.
```bash
$ cd ~/dev	
$ sudo python sonata/examples/newly_opened_connections/send.py
```

### Section 2: Detecting IoT Devices

#### Background
* What are IoT devices?
* Why do we want to detect their presence in the network?
* How can we detect these devices?

#### Expressing the Query
We will now describe a simple query one can express with Sonata to detect presence of
IoT devices. 
* Identify hosts that send **more** than `Th1` DNS queries.
* Identify hosts that receive DNS response for **less** than `Th2` unique resolved IP addresses. 

#### Testing
To test your query, follow the steps below:
* Cleanup
```bash
$ sudo sh cleanup.sh
```

* Load the application
```bash
$ sudo $SPARK_HOME/bin/spark-submit sonata/tutorial/Part-2/sonata_app.py
```

* Send the traffic
```bash
$ cd ~/dev	
$ sudo python sonata/tutorial/Part-2/send.py
```
 
Check the log file. 
### Troubleshooting
* Check the grammar for Sonata queries [here]().
* List of packet fields for Sonata queries are listed [here]().
* Make sure you load the app before sending the traffic.
* ...
